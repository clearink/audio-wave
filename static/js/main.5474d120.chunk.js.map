{"version":3,"sources":["http/index.js","utils/index.js","components/Wave/index.js","App.js","index.js"],"names":["request","options","method","Promise","resolve","axios","timeout","then","data","status","catch","err","message","error","getAudio","url","a","responseType","PAUSED","Wave","buffer","act","AudioContext","sourceNode","state","lastPlayTime","startTime","peaks","container","cover","lineCtx","coverCtx","gain","waveColor","coverColor","regions","animationID","this","length","Math","max","duration","clientWidth","canvas","style","width","fillStyle","decodeAudioData","reload","setCanvasOptions","getPeaks","drawWave","pause","result","slideWidth","getChannelData","len","i","maxV","minV","start","end","j","value","push","xStep","beginPath","fillRect","height","y","lineTo","fill","clearRect","clearWave","getCurrentTime","offset","currentTime","play","createSourceNode","round","requestAnimationFrame","animation","bind","finished","disconnect","createBufferSource","connect","destination","cancelAnimationFrame","stop","AudioWave","props","waveRef","useRef","wrapRef","coverRef","coverCanvasRef","lineCanvasRef","useEffect","current","getContext","resize","fn","delay","timer","args","setTimeout","apply","throttle","window","addEventListener","removeEventListener","src","load","className","ref","onClick","e","pos","target","getBoundingClientRect","resizeCover","clientX","left","type","App","useState","setData","onChange","fr","FileReader","files","file","readAsArrayBuffer","onload","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.5474d120.chunk.js","sourcesContent":["import axios from \"axios\";\r\nimport { message } from \"antd\";\r\n\r\nconst request = options => {\r\n  const { method = \"get\" } = options;\r\n  return new Promise(resolve => {\r\n    axios({ ...options, method, timeout: 5000 })\r\n      .then(data => {\r\n        if (data.status === 200) {\r\n          resolve(data);\r\n        }\r\n      })\r\n      .catch(err => {\r\n        message.error(\"请求失败\");\r\n      });\r\n  });\r\n};\r\n\r\nexport const getAudio = async url => {\r\n  const data = await request({\r\n    url,\r\n    responseType: \"arraybuffer\"\r\n  });\r\n  return data.data;\r\n};\r\n","const PLAYING = \"playing\";\r\nconst PAUSED = \"paused\";\r\nconst FINISHED = \"finished\";\r\n\r\nexport class Wave {\r\n  buffer = null;\r\n  act = new AudioContext();\r\n  sourceNode = null;\r\n\r\n  state = PAUSED;\r\n\r\n  lastPlayTime = 0;\r\n  startTime = 0;\r\n\r\n  peaks = [];\r\n\r\n  container = null;\r\n  cover = null;\r\n\r\n  lineCtx = null;\r\n  coverCtx = null;\r\n\r\n  gain = 1;\r\n\r\n  options = { waveColor: \"#555\", coverColor: \"#37A2DF\" };\r\n\r\n  regions = [];\r\n\r\n  animationID = null;\r\n  constructor(options) {\r\n    this.options = { ...this.options, ...options };\r\n\r\n    this.container = options.container;\r\n    this.lineCtx = options.lineCtx;\r\n    this.coverCtx = options.coverCtx;\r\n    this.cover = options.cover;\r\n    this.regions = options.regions;\r\n  }\r\n\r\n  setCanvasOptions() {\r\n    //绘图颜色  canvas宽度,长度\r\n\r\n    const length = Math.max(\r\n      this.buffer.duration * 30,\r\n      this.container.clientWidth\r\n    );\r\n    this.lineCtx.canvas.style.width = length + \"px\";\r\n    this.lineCtx.canvas.width = length;\r\n    this.lineCtx.fillStyle = this.options.waveColor;\r\n\r\n    this.coverCtx.canvas.style.width = length + \"px\";\r\n    this.coverCtx.canvas.width = length;\r\n    this.coverCtx.fillStyle = this.options.coverColor;\r\n  }\r\n\r\n  //加载数据\r\n  async load(data) {\r\n    this.buffer = await this.act.decodeAudioData(data); //解析数据\r\n    this.reload();\r\n    this.setCanvasOptions(); //设定canvas\r\n    this.getPeaks(); //获取波峰波谷\r\n    this.drawWave();\r\n  }\r\n  //获取数据中的波峰波谷\r\n  reload() {\r\n    this.cover.style.width = \"0px\";\r\n    this.pause();\r\n    this.startTime = 0;\r\n  }\r\n\r\n  getPeaks() {\r\n    const result = [];\r\n    const slideWidth = ~~(this.buffer.length / this.lineCtx.canvas.width); //取样窗口大小\r\n\r\n    const data = this.buffer.getChannelData(0);\r\n    const len = data.length;\r\n    //求出每个滑动窗口中的最大值和最小值\r\n    for (let i = 0; i * slideWidth < len; i++) {\r\n      let maxV = 0;\r\n      let minV = 0;\r\n      let start = i * slideWidth;\r\n      let end = start + slideWidth;\r\n\r\n      for (let j = start; j < end && j < len; j++) {\r\n        const value = data[j];\r\n        if (maxV < value) {\r\n          maxV = value;\r\n        }\r\n        if (minV > value) {\r\n          minV = value;\r\n        }\r\n      }\r\n      result.push(maxV, minV);\r\n    }\r\n    this.peaks = result;\r\n  }\r\n  /**\r\n   * 显示波形\r\n   *\r\n   */\r\n  drawWave() {\r\n    const canvas = this.lineCtx.canvas;\r\n    const length = this.peaks.length;\r\n    const xStep = canvas.width / length;\r\n    this.lineCtx.beginPath();\r\n    this.coverCtx.beginPath();\r\n    this.lineCtx.fillRect(0, canvas.height / 2, canvas.width, 1);\r\n    this.coverCtx.fillRect(0, canvas.height / 2, canvas.width, 1);\r\n    for (let i = 0; i < length; i += 2) {\r\n      let y = ((1 - this.peaks[i] * this.gain) * canvas.height) / 2;\r\n      this.lineCtx.lineTo(i * xStep, y);\r\n      this.coverCtx.lineTo(i * xStep, y);\r\n    }\r\n    for (let i = length - 1; i >= 0; i -= 2) {\r\n      let y = ((1 - this.peaks[i] * this.gain) * canvas.height) / 2;\r\n      this.lineCtx.lineTo(i * xStep, y);\r\n      this.coverCtx.lineTo(i * xStep, y);\r\n    }\r\n    this.lineCtx.fill(); //fill() 不需要调用closePath()\r\n    this.coverCtx.fill(); //fill() 不需要调用closePath()\r\n  }\r\n\r\n  //清除波形\r\n  clearWave() {\r\n    const canvas = this.lineCtx.canvas;\r\n    this.lineCtx.clearRect(0, 0, canvas.width, canvas.height);\r\n    this.coverCtx.clearRect(0, 0, canvas.width, canvas.height);\r\n  }\r\n\r\n  /**\r\n   * 调整波形\r\n   */\r\n  resize() {\r\n    if (!this.buffer) return;\r\n    this.setCanvasOptions();\r\n    this.getPeaks();\r\n    this.clearWave();\r\n    this.drawWave();\r\n\r\n    //修正当前播放时间位置\r\n    this.cover.style.width =\r\n      (this.getCurrentTime() * this.lineCtx.canvas.width) /\r\n        this.buffer.duration +\r\n      \"px\";\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} offset\r\n   * 设置覆盖长度, 设置当前播放时间\r\n   */\r\n  resizeCover(offset) {\r\n    if (!this.buffer) return;\r\n    const currentTime =\r\n      (offset / this.lineCtx.canvas.width) * this.buffer.duration;\r\n\r\n    this.cover.style.width = (offset | 0) + \"px\";\r\n\r\n    this.startTime = currentTime;\r\n\r\n    if (this.state === PLAYING) {\r\n      this.state = PAUSED;\r\n      this.play();\r\n    } else {\r\n      this.state = PAUSED;\r\n      this.createSourceNode();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * 动画,设置cover层的宽度\r\n   */\r\n  animation() {\r\n    const width = Math.round(\r\n      (this.getCurrentTime() / this.buffer.duration) * this.lineCtx.canvas.width\r\n    );\r\n    this.cover.style.width = width + \"px\";\r\n    if (width < this.lineCtx.canvas.width) {\r\n      this.animationID = requestAnimationFrame(this.animation.bind(this));\r\n    } else {\r\n      this.finished();\r\n    }\r\n  }\r\n\r\n  createSourceNode() {\r\n    if (this.sourceNode) {\r\n      this.sourceNode.disconnect();\r\n    }\r\n    this.sourceNode = this.act.createBufferSource();\r\n    this.sourceNode.buffer = this.buffer;\r\n    this.sourceNode.connect(this.act.destination);\r\n  }\r\n\r\n  play() {\r\n    if (!this.buffer || this.state === PLAYING) return;\r\n    this.createSourceNode();\r\n    this.state = PLAYING;\r\n\r\n    this.lastPlayTime = this.act.currentTime; //重新设置标志位\r\n    this.sourceNode.start(0, this.getCurrentTime());\r\n\r\n    //重新开始动画\r\n    cancelAnimationFrame(this.animationID);\r\n    this.animationID = requestAnimationFrame(this.animation.bind(this));\r\n  }\r\n  pause() {\r\n    try {\r\n      this.sourceNode.stop(0);\r\n    } catch {}\r\n    this.startTime = this.getCurrentTime(); //记录当前播放位置\r\n    this.state = PAUSED;\r\n    cancelAnimationFrame(this.animationID);\r\n  }\r\n\r\n  finished() {\r\n    this.cover.style.width = this.lineCtx.canvas.width + \"px\";\r\n    this.state = FINISHED;\r\n    this.startTime = 0;\r\n  }\r\n  getCurrentTime() {\r\n    switch (this.state) {\r\n      case PLAYING:\r\n        return this.startTime + this.act.currentTime - this.lastPlayTime;\r\n      case PAUSED:\r\n        return this.startTime;\r\n      case FINISHED:\r\n        return this.buffer.duration;\r\n      default:\r\n        return 0;\r\n    }\r\n  }\r\n}\r\n\r\nexport class Region {\r\n  constructor(start, end) {\r\n    this.start = start;\r\n    this.end = end;\r\n  }\r\n}\r\n\r\nexport function throttle(fn, delay = 500) {\r\n  let timer = null;\r\n  return function(...args) {\r\n    if (timer) return;\r\n    timer = setTimeout(() => {\r\n      fn.apply(this, args);\r\n      timer = null;\r\n    }, delay);\r\n  };\r\n}\r\n","import React, { useEffect, useRef } from \"react\";\r\nimport { getAudio } from \"@/http\";\r\nimport { Wave, throttle } from \"@/utils\";\r\nimport { Button, Icon } from \"antd\";\r\n\r\nimport \"./style.css\";\r\nfunction AudioWave(props) {\r\n  const waveRef = useRef(null);\r\n  const wrapRef = useRef(null);\r\n  const coverRef = useRef(null);\r\n  const coverCanvasRef = useRef(null);\r\n  const lineCanvasRef = useRef(null);\r\n  useEffect(() => {\r\n    const lineCtx = lineCanvasRef.current.getContext(\"2d\");\r\n    const coverCtx = coverCanvasRef.current.getContext(\"2d\");\r\n    waveRef.current = new Wave({\r\n      container: wrapRef.current,\r\n      cover: coverRef.current,\r\n      coverCtx: coverCtx,\r\n      lineCtx: lineCtx,\r\n      regions: []\r\n    });\r\n\r\n    const resize = throttle(() => {\r\n      waveRef.current.resize();\r\n    });\r\n    window.addEventListener(\"resize\", resize);\r\n    return () => {\r\n      window.removeEventListener(\"resize\", resize);\r\n    };\r\n  }, []);\r\n\r\n  useEffect(() => {\r\n    if (props.src) {\r\n      getAudio(props.src).then(data => {\r\n        waveRef.current.load(data);\r\n      });\r\n    } else if (props.data) {\r\n      waveRef.current.load(props.data).then(() => {});\r\n    }\r\n  }, [props.src, props.data]);\r\n  const handlePlayClick = () => {\r\n    waveRef.current.play();\r\n  };\r\n  const handlePauseClick = () => {\r\n    waveRef.current.pause();\r\n  };\r\n  const handleChangeCurrentTime = e => {\r\n    const pos = e.target.getBoundingClientRect();\r\n    waveRef.current.resizeCover(e.clientX - pos.left);\r\n  };\r\n  return (\r\n    <>\r\n      <div className=\"wrap\" ref={wrapRef} onClick={handleChangeCurrentTime}>\r\n        <div className=\"cover\" ref={coverRef}>\r\n          <canvas ref={coverCanvasRef}></canvas>\r\n        </div>\r\n        <canvas className=\"line\" ref={lineCanvasRef}></canvas>\r\n      </div>\r\n\r\n      <Button type=\"primary\" onClick={handlePlayClick}>\r\n        <Icon type=\"play-circle\" />\r\n      </Button>\r\n      <Button type=\"primary\" onClick={handlePauseClick}>\r\n        <Icon type=\"pause\" />\r\n      </Button>\r\n    </>\r\n  );\r\n}\r\nexport default AudioWave;\r\n","import React, { useState } from \"react\";\n\nimport WaveAudio from \"@/components/Wave\";\nfunction App() {\n  const [data, setData] = useState(null);\n\n  const handleChange = e => {\n    const fr = new FileReader();\n    if (e.target.files.length) {\n      const file = e.target.files[0];\n\n      fr.readAsArrayBuffer(file);\n      fr.onload = () => {\n        setData(fr.result);\n      };\n    }\n  };\n  return (\n    <>\n      <WaveAudio src={\"/assets/audio/3.mp3\"} />\n      <div>\n        <input type=\"file\" onChange={handleChange} />\n        <WaveAudio data={data} />\n      </div>\n    </>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));"],"sourceRoot":""}